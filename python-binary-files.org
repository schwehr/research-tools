#+BEGIN_COMMENT
Local Variables:
mode: org
mode: flyspell
mode: auto-fill
End:
#+END_COMMENT

#+STARTUP: showall

#+TITLE:     Chapter XXX: Python - parsing binary data files
#+AUTHOR:    Kurt Schwehr
#+EMAIL:     schwehr@ccom.unh.edu>
#+DATE:      $Date: $
#+DESCRIPTION: Marine Research Data Manipulation and Practices - Python
#+TEXT:      $Id: kurt-2010.org 13030 2010-01-14 13:33:15Z schwehr $
#+KEYWORDS: 
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:nil toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:nil LaTeX:nil skip:t d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_HOME: http://schwehr.org

* Introduction

** Why learn about binary files?

Binary storage of data inside files is commonly used used over ASCII
to pack data much more densely and provide much faster access.
Converting ASCII to internal binary representations of data that the
computer uses takes a lot of time.  Additionally, it can be faster
than more general packaging schemes such as Netcdf and HDF5 by being
simpler.

There are many critical data sets available as binary data.  However,
there are often things that are wrong with the binary format that
prevent you from using it in the rest of your research and data
processing work.  Being able to read binary data is an essential skill
for people in the field you will encounter large numbers of binary
formats.  Being able to read these will give you valuable insight into
how these systems work.  For example, if you get a new version of the
software on a multibeam sonar and your analysis tools start having
trouble, your ability to decode the binary messages from the sonar may
save you from down time or even help you to avoid collect bad data
that would otherwise assume is fine if you did not look inside the
messages yourself.

** A warning about binary data

If you find yourself creating a new binary format for your work,
please stop.  There are too many formats in the world and formats like
HDF5 and SQLite3 provide very powerful containers that preexisting libraries
understand and these formats are self describing in that you can ask them
what they store.  It is difficult to create a good binary file format
and you will likely make many mistakes that would be avoided.
Providing clear documentation of binary file formats is extremely easy
to get wrong.

As we work through several existing binary formats, I will attempt to
point out what is right and wrong (in my opinion) in the design of
that particular format.

** What does it mean to be binary data?

FIX: write

* SBET - "simple" inertial navigation messages

An SBET file is log file coming from an Applanix POSPac inertial navigation
system.  These devices work at a very high frequency to merge GPS,
compass, gyroscopic, accelerometer, and other data that come in at a
variety of time intervals.  It will report its best estimate of what
your air, sea, undersea, or ground vehicle is doing in terms of
motion.  This is the critical data that allows you to combine
individual sonar pings or laser ranges to create a properly a
georeferenced model of the environment.

I have taken a sample file from a research cruise in Alaska on the
NOAA survey ship Fairweather.  To simplify the example I have only
kept every 1/10000th data message.  The original file had 22 million
reports and the new file has 166 reports.  When learning, smaller
examples are easier to work with!  I will not show you how I did this,
but once you have worked through this chapter, you should be able to
write a python program to subsample the data exactly as I have.

** Read the documentation

Applanix provides documentation for the POSPac SBET files.  It is
essential to look at the documentation (if it is available) before
starting to parse the data.  The documentation might not be perfect,
but it can save you tons of time (and likely frustration).

FIX: reference the actual documentation

FIX: table of the format.

** Initial look at an SBET file

Before digging in to the details of parsing with python, let's use the
command line and emacs to inspect what we have.  First take a look at
the file sizes.  I am not going to provide the original file, but I
have included it here so you can see how it differs from the small
sample.sbet file.

To download the file, you can save it from a web browser or pull it
down in the terminal using *curl* or *wget*.

#+BEGIN_SRC sh
curl -O http://vislab-ccom.unh.edu/~schwehr/Classes/2011/esci895-researchtools/sample.sbet
#+END_SRC

You will just have the sample.sbet, but here I am showing you both the
original and the smaller "sample.sbet":

#+BEGIN_EXAMPLE
ls -l *.sbet
-rw-r--r--  1 schwehr  staff  225820248 Dec 12 09:02 original.sbet
-rw-r--r--  1 schwehr  staff      22712 Dec 14 12:44 sample.sbet
#+END_EXAMPLE

It is often good to use the unix *file* command to see if it knows
about a particular file type.  Here we discover that *file* is not
much help, but it does tell us that this is binary "data".

#+BEGIN_EXAMPLE
file *.sbet
original.sbet: data
sample.sbet:   data
#+END_EXAMPLE

We can try to see if there is any embedded text later in the data, as
file only checks a bit of the beginning of the file.  The unix
*strings* command will scan through a file and find sections that have
4 or more printable characters in a row.  To avoid too much random
junk that just happens to match the character codes of ASCII, we will
ask *string* to return only matches of 6 or more characters
much j

Octal dump also has a mode where it will print out the special meaning
of any bytes that might have special meaning.  These are things like
new lines (nl), start message (stx), end message (etx), and so forth.
Unfortunately, there is nothing obvious about the format.  The output
here is not helpful.

#+BEGIN_EXAMPLE
od -a sample.sbet  | head
0000000    ##  g   ####t   #   q dc4   A   ### H soh   # nak   ### ####?
0000020    G   ####f   Q   ##  z eot   ##  n   ### ##  ##dle   #   )   @
0000040    K   ##  #  9a   *   ### $   @   R   #  90  83   |   ####### ?
0000060    ###yn   ##  ##  ### f   ##  ? esc   u   # etx bel  88   e   #
0000100    #  vt   #   '   ######  #   ?   #   ### #   2   8  90   #   #
0000120    z   ##  = can   #####   ##  #   ### R   ### $   #   e   ### #
0000140    #####   ### #   #   ##  ##  # stx   <   w   u  83   #####   ?
0000160    ### B   #####   ###### 95   ?   m   #  83   4   /   #  9d   ?
0000200   si   { etb   D   ##  ### {   #   ###ff  99 etx  84   r dc4   A
0000220  dc3  95   #   ### e   ### ####?   #######c3 stx   #   z eot   ##
#+END_EXAMPLE

Better yet, Octal Dump has a mode that will try to treat the file as
uniform binary data (for example, a series of 4 byte integers).
Since we know that our SBET file will contain a series of 17 doubles
(8 bytes each) in a row, let's try out a sample file that contains the
numbers 0 through 16,

#+BEGIN_EXAMPLE
od -t fD s1.bin 
0000000     0.000000000000000e+00    1.000000000000000e+00
0000020     2.000000000000000e+00    3.000000000000000e+00
0000040     4.000000000000000e+00    5.000000000000000e+00
0000060     6.000000000000000e+00    7.000000000000000e+00
0000100     8.000000000000000e+00    9.000000000000000e+00
0000120     1.000000000000000e+01    1.100000000000000e+01
0000140     1.200000000000000e+01    1.300000000000000e+01
0000160     1.400000000000000e+01    1.500000000000000e+01
0000200     1.600000000000000e+01                         
0000210
#+END_EXAMPLE

It might look weird to you, but 1.40e+01 is actually the number 14.0.
We can now try to same thing on our sbet.  Each datagram has 17 fields
of 8 byte doubles for a total of 168 bytes.  If we want to view the
first two datagrams, we can ask *od* to print out just up to a certain
byte count with the "-n" option.  Two datagrams will be be 272 bytes.

#+BEGIN_EXAMPLE
od -N 272 -t fD  sample.sbet 
0000000     3.349590048233234e+05    1.054952263850787e+00
0000020    -2.559965741819528e+00    1.282630055734282e+01
0000040     1.043782504645391e+01    9.982283181789831e-01
0000060     1.828280453666403e-01   -2.628339481204234e-03
0000100     1.141660305793682e-01   -9.985686530029529e-02
0000120    -4.015467392667414e-01   -8.249097558096672e-01
0000140    -3.413483211034812e-01    7.018300645653144e-02
0000160     2.132017683362876e-02    2.900003202460815e-02
0000200    -6.807197876212325e-03    3.350090035135288e+05
0000220     1.055028809795947e+00   -2.559907928689193e+00
0000240     1.272997378104385e+01    1.042404852578803e+01
0000260     1.287703038920362e+00    2.491409993943237e-01
0000300     6.418474606643030e-03    1.040782092443994e-01
0000320    -1.198332534114335e-01   -4.021915714645197e-01
0000340     8.870342742214299e-02    7.607961433375590e-02
0000360    -1.743265137730372e+00    1.903246157839654e-02
0000400     7.630558594581809e-02    3.111229241529141e-03
0000420
#+END_EXAMPLE

If we look at the first number from both datagrams, which is supposed
to be a measure of time, we can see that the numbers are
3.349590048233234e+05 and 3.350090035135288e+05.  It's hard to see,
but it looks like time is moving slightly forward.  This means we are
on the right track.

It's time to switch from the terminal to python!

** Opening a file and reading the data in python

There are several ways to open a file and access the data.  Let's
start with the simplest method.  If you try this on a multi-gigabyte
file, it will take a really long time, but in the case of a small test
file, this is a great way to get started.  Later, I will show you how
to read the file a bit at a time and finally, I will show you a fancy
method called mmap that can has the potential to greatly speed up your
program.

First, open the file.  This will return a file object back to you that
you can use to read or manipulate the contents of the file.

FIX: link to python file object documentation

FIX: this does not work in python3!

#+BEGIN_SRC python
sbet_file = open('sample.sbet')
#+END_SRC

There are many things you can do with a file, but in our case, we want
to pull the entire file into a variable.

#+BEGIN_SRC python
sbet_data = sbet_file.read()

type(sbet_data)
# Out: <type 'str'>

len(sbet_data)
# 22712
#+END_SRC

** Decoding values with python's struct module

We now have 22712 bytes in a string.  We can start using the python
*struct* module to begin decoding the file.  Struct is designed just
for our needs - going between python and binary data.  We specify
letter codes and python does the hard work of figuring out how to
decode the bytes from the type.  However, If we specify a type
different than what is actually in the data, python will happily
decode the data and give us back meaningless junk.  Pack goes from
python to binary and unpack goes from binary to python variable types.

FIX: put in table of types

Let's give it a try on the time field.  'd' is for doubles and we want
one double that takes up the first 8 bytes of the data.  struct is
designed to decode a whole bunch of values at the same time, so it
returns the results in a tuple (unchangeable list).  Note that you
must pass in exactly the right number of bytes to unpack for the
format codes that you give it, so we will pull a sub-array of the
sbet_data array with "[0:8]".

#+BEGIN_SRC python
struct.unpack('d',sbet_data[0:8])
# (334959.0048233234,)

struct.unpack('d',sbet_data[0:8])[0]
# 334959.0048233234
#+END_SRC

The next two fields are the latitude and longitude in radians.  Let's
first grab the second two values at the same time.  Being the 2nd
double, the latitude will start at position 8.  We then at 16 bytes on
to the 8 to get the stopping position of the longitude.

#+BEGIN_SRC python
struct.unpack('dd',sbet_data[8:24])
(1.0549522638507869, -2.559965741819528)
#+END_SRC

Reading latitude and longitude in radians is no fun.  The math module
has, among many other things, functions to convert between degrees and
radians.  Also, if you know how many values will be returned from a
function call, you can specify that many variables before the equal
sign and python will put the results into each variable in order.

#+BEGIN_SRC python
lat_rad, lon_rad = struct.unpack('dd',sbet_data[8:24])
math.degrees(lat_rad)
# 60.444312306421736

In [36]: math.degrees(lon_rad)
# -146.6752327043359
#+END_SRC

You can now go look at a map for 60.4N and 146.7W to see the area
where the Fairweather was located when collecting this data.

Since we have 17 variables, it can be annoying to do either 17
struct.unpack calls or write out 17 "d" characters in a string, so
struct allows you to put a number before the d to specify the number
of values you would like to decode.  Here is the sample latitude and
longitude example, but using "2d" rather than "dd".

#+BEGIN_SRC python
struct.unpack('2d',sbet_data[8:24])
(1.0549522638507869, -2.559965741819528)
#+END_SRC

We can now try decoding all 17 variables.  This is not so much fun.

#+BEGIN_SRC python
struct.unpack('17d',sbet_data[0:8*17])
Out[38]: 
(334959.0048233234,
 1.0549522638507869,
 -2.559965741819528,
 12.826300557342815,
 10.437825046453915,
 0.998228318178983,
 0.18282804536664027,
 -0.0026283394812042344,
 0.11416603057936824,
 -0.09985686530029529,
 -0.40154673926674145,
 -0.8249097558096672,
 -0.3413483211034812,
 0.07018300645653144,
 0.021320176833628756,
 0.029000032024608147,
 -0.006807197876212325)
#+END_SRC

We can use the field names separated by commas to fill in all the
variable.  The "\" character allows you to continue a line of code on
to the next line.

#+BEGIN_SRC python
time, latitude, longitude, altitude, \
    x_vel, y_vel, z_vel, \
    roll, pitch, platform_heading, wander_angle, \
    x_acceleration, y_acceleration, z_acceleration, \
    x_angular_rate, y_angular_rate, z_angular = struct.unpack('ddddddddddddddddd',data[0:17*8])
#+END_SRC

It is really hard to follow what is going on in that last python call
to unpack.   Rather than list out each field name, we can have python
create a dictionary with named entries for each of our values.

#+BEGIN_SRC python
field_names = ('time', 'latitude', 'longitude', 'altitude', \
          'x_vel', 'y_vel', 'z_vel', \
          'roll', 'pitch', 'platform_heading', 'wander_angle', \
          'x_acceleration', 'y_acceleration', 'z_acceleration', \
          'x_angular_rate', 'y_angular_rate', 'z_angular')

values = struct.unpack('17d',sbet_data[0:8*17])

# Crazy stuff happens here!
dict(  zip(field_names, values) )
#+END_SRC

The last command needs some explanation.  First here is what it
returns:

#+BEGIN_SRC python
{'altitude': 12.826300557342815,
 'latitude': 1.0549522638507869,
 'longitude': -2.559965741819528,
 'pitch': 0.11416603057936824,
 'platform_heading': -0.09985686530029529,
 'roll': -0.0026283394812042344,
 'time': 334959.0048233234,
 'wander_angle': -0.40154673926674145,
 'x_acceleration': -0.8249097558096672,
 'x_angular_rate': 0.021320176833628756,
 'x_vel': 10.437825046453915,
 'y_acceleration': -0.3413483211034812,
 'y_angular_rate': 0.029000032024608147,
 'y_vel': 0.998228318178983,
 'z_acceleration': 0.07018300645653144,
 'z_angular': -0.006807197876212325,
 'z_vel': 0.18282804536664027}
#+END_SRC

That is a python dictionary with each field stored by name.  You might
ask how the heck that works!  First the call to zip combines the list
of field names and the list of values into paired entries.  They have
to be in *exactly* the same order.  Here is an example with the first
4 entries in each:

#+BEGIN_SRC python
zip(field_names[:4], values[:4])

# Results in:
[('time', 334959.0048233234),
 ('latitude', 1.0549522638507869),
 ('longitude', -2.559965741819528),
 ('altitude', 12.826300557342815)]
#+END_SRC

The python dictionary can be created by a sequence of key and value
pairs (often referred to as k,v).  You now have a dictionary that you
can work with or pass around.  You can do conversions and store them
back into the dictionary and only have to pass around one "thing".

#+BEGIN_SRC python
sbet_values = dict(zip (field_names, values))

# convert radians to degrees and put it in a new dictionary key
sbet_values['lat_deg'] = math.degrees(sbet_values['latitude'])

sbet_values['lat_deg']
# 60.444312306421736
#+END_SRC

** Creating a function that reads an SBET record

*** A stub function

Now that we have the basics of decoding a datagram down, we should
turn it into a function so that we can reuse it in the future.  Create
a new file called sbet.py in your favorite text editor (in emacs: C-x
C-f sbet.py).  We are going to work on our function by using ipython
to test it.

#+BEGIN_SRC sh
ipython
#+END_SRC

Now start off by creating a file with a "stub" function that does not
do anything real.  "stubs" are things that are placeholders that do
not do much if anything.

#+BEGIN_SRC python
# Decode Applanix POSPac SBET IMU binary files

def decode():
    print "hello from decode"
#+END_SRC

The above python code creates one function that is started by the
"def" for define function.  "decode" is the function name.  All
functions have an "argument list" that is in the "()".  These are the
variables that you will pass into the function.  By having nothing in
the parentheses, you are saying that the decode function does not let
you pass anything to it.

As we say in the previous chapters, block or groups of code are
separated by indentation.  Any change of the indentation either stops
or starts a block.  By indenting 4 spaces, I start a new function.
You can use any indentation, but 4 is the convention in the python
community.

A python file can work exactly like the modules you have been using so
far.  Try importing it and kick the tires.  With *import* it is
important to notice that you leave off the ".py".  In our case here,
be sure to start ipython in the same directory as you are putting the
sbet.py and sample.sbet files.

#+BEGIN_SRC python
import sbet
sbet.decode()
# hello from decode
#+END_SRC

You now have a working module.  It doesn't do much yet, but we will
get there quickly.  As you make changes to the python file, if you
rerun the "sbet.decode()", you will find that nothing changes.  You
need to reload the python file into ipython with the *reload*
command.  Change the file to match what I have here:

#+BEGIN_SRC python
# Decode Applanix POSPac SBET IMU binary files

# You will see this when you load or reload this file, this line will print
print "load or reload happening"

def decode():
    print "hello from decode"
    print 7*6
#+END_SRC

The new first print line is not inside a function.  It is there to
show you that anything not inside a function (or later a you will see
a class), will get run immediately.  This is helpful here - we can see
if the reload actually happened.  Try a reload in ipython.  Once you
have reloaded the sbet.py module, you can now use the new version of
the decode function.

#+BEGIN_SRC python
reload(sbet)
# load or reload happening

sbet.decode()
# hello from decode
# 42
#+END_SRC

*** Getting data ready to parse

Parsing means to pull apart some data or text into pieces that we can
use locally.  Think of writing a program to find all the words in a
text document.  The "parser" has to take the text and break into
chunks separated by white space (new lines, space characters, or tabs)
or punctuation.  But before you can parse data, you need to load the
data.  We will use the simplest approach as described above.  There
are faster ways, but it is usually better to get a working program
first before you try to make it go fast (call "optimizing").

We will put our controlling code into a function called "main".
Functions in a module (aka python file) can come in any order, but I
put my main functions at the bottom of the file.  This is just my
personal style.

Here is the program with the new main function that uses the open and
read calls discussed previously.

#+BEGIN_SRC python
# Decode Applanix POSPac SBET IMU binary files

# You will see this when you load or reload this file, this line will print
print "load or reload happening"

def decode():
    print "hello from decode"
    print 7*6

def main():
    print 'Starting main'
    sbet_file = open('sample.sbet')
    sbet_data = sbet_file.read()
    print 'Finishing main'
#+END_SRC

It still doesn't do anything useful, but we are getting closer!  Give
it a try to make sure it works.  You can see the prints at the
beginning and ending of the main function.

#+BEGIN_SRC python
reload(sbet)
# load or reload happening

In [12]: sbet.main()
# Starting main
# Finishing main
#+END_SRC

Now we need to pass in the data that we loaded in main to the decode
function.  We must add an argument to the decode function.  The name
of this argument has nothing to do with the name of what we pass in.
What ever is passed in first will get assigned to the first argument
inside the function.  So here, the contents of the sbet_data variable
will get assigned to the "data" variable inside the decode function.

#+BEGIN_SRC python
# Add data argument to decode
def decode(data):
    'Decipher a SBET datagram from binary'
    print "hello from decode"
    print 'Data length:', len(data)

def main():
    print 'Starting main'
    sbet_file = open('sample.sbet')
    sbet_data = sbet_file.read()
    print 'Read this many bytes:',len(sbet_data)

    decode(sbet_data)  # Pass in the sbet_data variable to decode
    
    print 'Finishing main'
#+END_SRC

It is also time to start doing a bit of documentation.  Python has a
mechanism called "doc strings".  If there is a string as the first
line of a file, function, class, or class method, then python
considers that string as the documentation for the class.  In the
above example, I have added a string right after the definition of the
*decode* function.  There are two ways to ask for help from ipython:
the help command and appending a ? after something:

#+BEGIN_SRC python
help(sbet.decode)
# Help on function decode in module sbet:
# 
# decode(data)
#     Decipher a SBET datagram from binary

sbet.decode?
# Type:           function
# Base Class:     <type 'function'>
# String Form:    <function decode at 0x11f09f0>
# Namespace:      Interactive
# File:           /Users/schwehr/Desktop/sbet/sbet.py
# Definition:     sbet.decode(data)
# Docstring:
#     Decipher a SBET datagram from binary
#+END_SRC 

So we have documentation, but a function that doesn't do anything.  I
know you are getting impatient with me, so let's actually decode the
first datagram in the SBET file.  Here is the new "decode" function
that actually does a little bit of decoding and prints the time,
latitude/longitude in degrees.

#+BEGIN_SRC python
def decode(data):
    "Decipher a SBET datagram from binary"
    print "Start decoding datagram"
    values = struct.unpack('17d',data[0:8*17])

    time = values[0]

    latitude = values[1]
    lat_deg = math.degrees(latitude)

    longitude = values[2]
    lon_deg = math.degrees(longitude)

    print 'results:', time, lat_deg, lon_deg
#+END_SRC

Since the decode function uses unpack from the struct library and
degrees from the math library, we need to add an import statement to
the top of the file.  You might wonder why if we have done an import
of math in ipython, why do we need it in the file?  imports only work
in the context of the local module or python interactive session.
Each module is independent and needs to tell python which modules it
needs.

#+BEGIN_SRC python
# Decode Applanix POSPac SBET IMU binary files

# The import must come before the decode function.
# In python, the convention is to put imports at the top of the file
# We can import several modules in one line by separating them with commas
import math, struct

# You will see this when you load or reload this file, this line will print
print "load or reload happening"
#+END_SRC

We should now be able to reload the sbet module and try it out
decoding actual data:

#+BEGIN_SRC python
reload(sbet)
# load or reload happening

sbet.main()
# Starting main
# Read this many bytes: 22712
# Start decoding datagram
# results: 334959.004823 60.4443123064 -146.675232704
# Finishing main
#+END_SRC

This is pretty exciting!  We now have a file that we can use to redo
a decoding.  It's not very flexible, but it works.  We need to work to
improve it to be more useful.

The first thing to do to make it more useful is to allow it to run
from the command line.  We can almost do that already, but not as
easily as we would like.  First quit ipython and get back to the
*bash* terminal prompt.  We can tell python to run a file:

#+BEGIN_SRC sh
python sbet.py
# load or reload happening
#+END_SRC

We need to add some special code that detects if the python is being
run as a main program.  There is a special trick in python to detect
this case using the *__name__* variable.  Add this line to your
sbet.py file:

#+BEGIN_SRC python
print '__name__', __name__
#+END_SRC

If you import the module from ipython, __name__ will be set to the
name of the module: in this case "sbet".  Run ipython and import sbet.

#+BEGIN_SRC python
import sbet
# load or reload happening
# __name__ sbet
#+END_SRC

If you exit ipython to bash, and use python to run the sbet script,
you will see that __name__ has changed to __main__.

#+BEGIN_SRC sh
python sbet.py
load or reload happening
__name__ __main__
#+END_SRC

Using this, we can add a check at the bottom of sbet.py to see if it
is being run as a script.  If so, we can right away start up the
process of getting the script going.  If sbet.py is imported, the code
will not run, which is what we want because it will be some other
code's job to use the functions in the sbet module.

#+BEGIN_SRC python
if __name__=='__main__':
    print 'starting to run script...'
    main()
    print 'script done!'
#+END_SRC

Then if we run the script using python from the bash prompt, it will
actually call the main() function and get things going.

#+BEGIN_SRC sh
cd && python sbet.py
# load or reload happening
# __name__ __main__

# starting to run script...
# Starting main
# Read this many bytes: 22712
# Start decoding datagram
# results: 334959.004823 60.4443123064 -146.675232704
# Finishing main
# script done!
#+END_SRC

It can be really annoying to have to remember to type python before
the script all the time.  You don't want to be required to tell other
people which language the script uses any time they want to run it.
There is a special mechanism that bash uses to see how it should run a
script file: it checks the first line.  If that line starts with a
*#!* ("pound bag"), then bash will use the program listed after to run
the rest of the file.  The trouble is that we don't know exactly where
python is installed on the computer.  It might be in /bin, /usr/bin,
or elsewhere.  Plus the person might have changed their path to point
to a different version of python that works better for them.  We want
to honor that choice.  There is a unix command called *env* that is
supposed to always be located in the same place.  It looks at the path
and finds the python interpreter.  This is the recommended way to
create a python script.  Add this line to the very beginning of your
sbet.py file.

#+BEGIN_SRC python
#!/usr/bin/env python
#+END_SRC

One more thing to fix.  You have to tell the computer that the file is
"executable".  Otherwise it will not think that it can run the file.
The *chmod* command will let you set the permissions on the sbet.py
file.  After chmod is run, not the extra "x" characters for executable
on the left side of the return from the *ls* command.

#+BEGIN_SRC sh
ls -l sbet.py
# -rw-r--r--  1 schwehr  staff  883 Dec 20 17:26 sbet.py

chmod +x sbet.py

ls -l sbet.py
# -rwxr-xr-x  1 schwehr  staff  883 Dec 20 17:26 sbet.py
#+END_SRC

Now you can run your sbet.py script without knowing that it is python
inside.

#+BEGIN_SRC sh
./sbet.py

# load or reload happening
# __name__ __main__
# starting to run script...
# Starting main
# Read this many bytes: 22712
# Start decoding datagram
# results: 334959.004823 60.4443123064 -146.675232704
# Finishing main
# script done!
#+END_SRC

Before we go any farther, let's clean up the file and give it a look
over.  I have deleted extra print statements.

#+BEGIN_SRC python
#!/usr/bin/env python

# Decode Applanix POSPac SBET IMU binary files

import math, struct

def decode(data):
    "Decipher a SBET datagram from binary"
    values = struct.unpack('17d',data[0:8*17])

    time = values[0]

    latitude = values[1]
    lat_deg = math.degrees(latitude)

    longitude = values[2]
    lon_deg = math.degrees(longitude)

    print 'results:', time, lat_deg, lon_deg

def main():
    sbet_file = open('sample.sbet')
    sbet_data = sbet_file.read()

    decode(sbet_data)
    
if __name__=='__main__':
    main()
#+END_SRC

Now let's change the decode function to get all of the fields as we
did before.  I am going to use the *dict* and *zip* method before, but
if you are writing your own decoder for something else, you can
certainly decode each field individually.  Add the field_names to your
file before the decode function and change decode to look like this:

#+BEGIN_SRC python
field_names = ('time', 'latitude', 'longitude', 'altitude', \
          'x_vel', 'y_vel', 'z_vel', \
          'roll', 'pitch', 'platform_heading', 'wander_angle', \
          'x_acceleration', 'y_acceleration', 'z_acceleration', \
          'x_angular_rate', 'y_angular_rate', 'z_angular')

def decode(data):
    "Decipher a SBET datagram from binary"
    values = struct.unpack('17d',data[0:8*17])

    # Create a dictionary for all the values
    sbet_values = dict(zip (field_names, values))

    sbet_values['lat_deg'] = math.degrees(sbet_values['latitude'])
    sbet_values['lon_deg'] = math.degrees(sbet_values['longitude'])

    print 'results:'
    for key in sbet_values:
        print '    ', key, sbet_values[key]
#+END_SRC

I have change the printing of the result at the end to be easier to
read.  If we just print a dictionary, it will be a big mush.  However,
looping over a dictionary with a for loop will return the keys of the
dictionary one by one.  Try running the resulting program.

#+BEGIN_SRC sh
./sbet.py 
# results:
#      x_acceleration -0.82490975581
#      x_angular_rate 0.0213201768336
#      platform_heading -0.0998568653003
#      y_angular_rate 0.0290000320246
#      pitch 0.114166030579
#      altitude 12.8263005573
#      z_vel 0.182828045367
#      lat_deg 60.4443123064
#      longitude -2.55996574182
#      roll -0.0026283394812
#      y_vel 0.998228318179
#      y_acceleration -0.341348321103
#      time 334959.004823
#      latitude 1.05495226385
#      lon_deg -146.675232704
#      z_acceleration 0.0701830064565
#      z_angular -0.00680719787621
#      x_vel 10.4378250465
#      wander_angle -0.401546739267
#+END_SRC
